// Package schema provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1-0.20250820092511-bdc4edce7476 DO NOT EDIT.
package schema

import (
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for ProfileType.
const (
	Email ProfileType = "email"
	Text  ProfileType = "text"
	Url   ProfileType = "url"
)

// Defines values for QuestionStatus.
const (
	Answered QuestionStatus = "answered"
	Read     QuestionStatus = "read"
	Unread   QuestionStatus = "unread"
)

// Defines values for ReportRequestTargetType.
const (
	ReportRequestTargetTypeQuestion ReportRequestTargetType = "question"
	ReportRequestTargetTypeUser     ReportRequestTargetType = "user"
)

// Defines values for SortOrder.
const (
	Asc  SortOrder = "asc"
	Desc SortOrder = "desc"
)

// Defines values for QuestionFilterSortBy.
const (
	QuestionFilterSortByCreatedAt QuestionFilterSortBy = "createdAt"
	QuestionFilterSortByUpdatedAt QuestionFilterSortBy = "updatedAt"
)

// Defines values for SentQuestionFilterSortBy.
const (
	SentQuestionFilterSortByCreatedAt SentQuestionFilterSortBy = "createdAt"
	SentQuestionFilterSortByUpdatedAt SentQuestionFilterSortBy = "updatedAt"
)

// Defines values for GetPublicQAsParamsSortBy.
const (
	GetPublicQAsParamsSortByCreatedAt GetPublicQAsParamsSortBy = "createdAt"
	GetPublicQAsParamsSortByUpdatedAt GetPublicQAsParamsSortBy = "updatedAt"
)

// Defines values for GetReceivedQuestionsParamsSortBy.
const (
	GetReceivedQuestionsParamsSortByCreatedAt GetReceivedQuestionsParamsSortBy = "createdAt"
	GetReceivedQuestionsParamsSortByUpdatedAt GetReceivedQuestionsParamsSortBy = "updatedAt"
)

// Defines values for GetSentQuestionsParamsSortBy.
const (
	CreatedAt GetSentQuestionsParamsSortBy = "createdAt"
	UpdatedAt GetSentQuestionsParamsSortBy = "updatedAt"
)

// Answer 回答
type Answer struct {
	AttachedImageList *[]ImageFile `json:"attachedImageList,omitempty"`
	Content           string       `json:"content"`
	CreatedAt         time.Time    `json:"createdAt"`
	Id                string       `json:"id"`
	IsPublic          bool         `json:"isPublic"`
	QuestionId        string       `json:"questionId"`
	UpdatedAt         time.Time    `json:"updatedAt"`
}

// AnswerCreateRequest 回答作成リクエスト
type AnswerCreateRequest struct {
	AttachedImageIdList *[]string `json:"attachedImageIdList,omitempty"`
	Content             string    `json:"content"`
	IsPublic            bool      `json:"isPublic"`
}

// BlockedUser ブロックユーザー情報
type BlockedUser struct {
	// BlockedUser 公開用ユーザー情報
	BlockedUser PublicUserInfo `json:"blockedUser"`
	CreatedAt   time.Time      `json:"createdAt"`
	Id          string         `json:"id"`
	UpdatedAt   time.Time      `json:"updatedAt"`
}

// ErrorDetails エラー詳細情報
type ErrorDetails struct {
	Code    *string     `json:"code,omitempty"`
	Details interface{} `json:"details,omitempty"`
	Message string      `json:"message"`
}

// Identificator defines model for Identificator.
type Identificator struct {
	union json.RawMessage
}

// Identificator0 defines model for .
type Identificator0 = string

// Identificator1 defines model for .
type Identificator1 = string

// ImageFile 画像ファイル情報
type ImageFile struct {
	CreatedAt    time.Time `json:"createdAt"`
	Id           string    `json:"id"`
	MimeType     string    `json:"mimeType"`
	OriginalName string    `json:"originalName"`
	Size         int64     `json:"size"`
	Url          string    `json:"url"`
}

// LoginRequest ログインリクエスト
type LoginRequest struct {
	Id       Identificator `json:"id"`
	Password string        `json:"password"`
}

// LoginResponse ログインレスポンス
type LoginResponse struct {
	AccessToken  string `json:"accessToken"`
	RefreshToken string `json:"refreshToken"`

	// User ユーザープロフィール情報
	User User `json:"user"`
}

// NgWord NGワード
type NgWord struct {
	CreatedAt time.Time `json:"createdAt"`
	Id        string    `json:"id"`
	IsActive  bool      `json:"isActive"`
	UpdatedAt time.Time `json:"updatedAt"`
	Word      string    `json:"word"`
}

// NgWordCreateRequest NGワード追加リクエスト
type NgWordCreateRequest struct {
	Word string `json:"word"`
}

// ProfileBase プロフィール項目ベース
type ProfileBase struct {
	CreatedAt time.Time   `json:"createdAt"`
	Id        string      `json:"id"`
	Name      string      `json:"name"`
	Order     int32       `json:"order"`
	Type      ProfileType `json:"type"`
	UpdatedAt time.Time   `json:"updatedAt"`
	Value     string      `json:"value"`
}

// ProfileEmail プロフィール項目ベース
type ProfileEmail = ProfileBase

// ProfileField プロフィール項目
type ProfileField struct {
	union json.RawMessage
}

// ProfileFieldUpdate プロフィール更新
type ProfileFieldUpdate struct {
	Id        *string `json:"id,omitempty"`
	IsVisible bool    `json:"isVisible"`
	Name      string  `json:"name"`
	Order     int32   `json:"order"`
	Value     string  `json:"value"`
}

// ProfileSite プロフィール項目ベース
type ProfileSite = ProfileBase

// ProfileTwitter プロフィール項目ベース
type ProfileTwitter = ProfileBase

// ProfileType defines model for ProfileType.
type ProfileType string

// ProfileUpdateRequest ユーザー情報更新リクエスト
type ProfileUpdateRequest struct {
	DisplayId     *string               `json:"displayId,omitempty"`
	DisplayName   *string               `json:"displayName,omitempty"`
	Email         *string               `json:"email,omitempty"`
	IconImageId   *string               `json:"iconImageId,omitempty"`
	ProfileFields *[]ProfileFieldUpdate `json:"profileFields,omitempty"`
}

// PublicQA 公開された質問・回答セット
type PublicQA struct {
	Answer struct {
		AttachedImageList *[]ImageFile `json:"attachedImageList,omitempty"`
		Content           string       `json:"content"`
		CreatedAt         time.Time    `json:"createdAt"`
	} `json:"answer"`

	// AnsweredBy 公開用ユーザー情報
	AnsweredBy PublicUserInfo `json:"answeredBy"`
	Id         string         `json:"id"`
	Question   struct {
		AttachedImageList *[]ImageFile `json:"attachedImageList,omitempty"`
		Content           string       `json:"content"`
		CreatedAt         time.Time    `json:"createdAt"`
		IsAnonymous       bool         `json:"isAnonymous"`
	} `json:"question"`
}

// PublicUserInfo 公開用ユーザー情報
type PublicUserInfo struct {
	DisplayId   string `json:"displayId"`
	DisplayName string `json:"displayName"`

	// IconImage 画像ファイル情報
	IconImage     *ImageFile      `json:"iconImage,omitempty"`
	ProfileFields *[]ProfileField `json:"profileFields,omitempty"`
}

// Question defines model for Question.
type Question = QuestionBase

// QuestionBase defines model for QuestionBase.
type QuestionBase struct {
	AttachedImageList *[]ImageFile `json:"attachedImageList,omitempty"`

	// Content 質問本文
	Content     string    `json:"content"`
	CreatedAt   time.Time `json:"createdAt"`
	Id          string    `json:"id"`
	IsAnonymous bool      `json:"isAnonymous"`

	// RecipientId 受信者ID
	RecipientId string `json:"recipientId"`

	// SenderId 送信者ID ログインユーザーの場合のみ
	SenderId *string `json:"senderId,omitempty"`

	// Status 質問ステータス
	Status    QuestionStatus `json:"status"`
	UpdatedAt time.Time      `json:"updatedAt"`
}

// QuestionCreateRequest 質問送信リクエスト
type QuestionCreateRequest struct {
	AttachedImageIdList *[]string `json:"attachedImageIdList,omitempty"`
	Content             string    `json:"content"`
	RecipientId         string    `json:"recipientId"`
}

// QuestionDetail 質問
type QuestionDetail = Question

// QuestionStatus 質問ステータス
type QuestionStatus string

// QuestionUpdateRequest 質問編集リクエスト
type QuestionUpdateRequest struct {
	AttachedImageIdList *[]string `json:"attachedImageIdList,omitempty"`
	Content             *string   `json:"content,omitempty"`
}

// ReportRequest 通報リクエスト
type ReportRequest struct {
	Details    *string                 `json:"details,omitempty"`
	Reason     string                  `json:"reason"`
	TargetId   string                  `json:"targetId"`
	TargetType ReportRequestTargetType `json:"targetType"`
}

// ReportRequestTargetType defines model for ReportRequest.TargetType.
type ReportRequestTargetType string

// SortOrder ソート順序
type SortOrder string

// User ユーザープロフィール情報
type User struct {
	CreatedAt time.Time `json:"createdAt"`

	// DisplayId ユーザーID（表示用、一意）
	DisplayId   string `json:"displayId"`
	DisplayName string `json:"displayName"`
	Email       string `json:"email"`

	// IconImage 画像ファイル情報
	IconImage *ImageFile `json:"iconImage,omitempty"`

	// Id 内部ID
	Id            string          `json:"id"`
	IsActive      bool            `json:"isActive"`
	ProfileFields *[]ProfileField `json:"profileFields,omitempty"`
	UpdatedAt     time.Time       `json:"updatedAt"`
}

// UserRegistrationRequest ユーザー登録リクエスト
type UserRegistrationRequest struct {
	DisplayId   string `json:"displayId"`
	DisplayName string `json:"displayName"`
	Email       string `json:"email"`
	Password    string `json:"password"`
}

// PaginationQueryLimit defines model for PaginationQuery.limit.
type PaginationQueryLimit = int32

// PaginationQueryPage defines model for PaginationQuery.page.
type PaginationQueryPage = int32

// QuestionFilterSortBy defines model for QuestionFilter.sortBy.
type QuestionFilterSortBy string

// QuestionFilterSortOrder ソート順序
type QuestionFilterSortOrder = SortOrder

// QuestionFilterStatus 質問ステータス
type QuestionFilterStatus = QuestionStatus

// SentQuestionFilterHasAnswer defines model for SentQuestionFilter.hasAnswer.
type SentQuestionFilterHasAnswer = bool

// SentQuestionFilterSortBy defines model for SentQuestionFilter.sortBy.
type SentQuestionFilterSortBy string

// SentQuestionFilterSortOrder ソート順序
type SentQuestionFilterSortOrder = SortOrder

// GetPublicQAsParams defines parameters for GetPublicQAs.
type GetPublicQAsParams struct {
	Page      *PaginationQueryPage      `form:"page,omitempty" json:"page,omitempty"`
	Limit     *PaginationQueryLimit     `form:"limit,omitempty" json:"limit,omitempty"`
	SortBy    *GetPublicQAsParamsSortBy `form:"sortBy,omitempty" json:"sortBy,omitempty"`
	SortOrder *SortOrder                `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`
}

// GetPublicQAsParamsSortBy defines parameters for GetPublicQAs.
type GetPublicQAsParamsSortBy string

// GetReceivedQuestionsParams defines parameters for GetReceivedQuestions.
type GetReceivedQuestionsParams struct {
	Page      *PaginationQueryPage              `form:"page,omitempty" json:"page,omitempty"`
	Limit     *PaginationQueryLimit             `form:"limit,omitempty" json:"limit,omitempty"`
	Status    *QuestionFilterStatus             `form:"status,omitempty" json:"status,omitempty"`
	SortBy    *GetReceivedQuestionsParamsSortBy `form:"sortBy,omitempty" json:"sortBy,omitempty"`
	SortOrder *QuestionFilterSortOrder          `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`
}

// GetReceivedQuestionsParamsSortBy defines parameters for GetReceivedQuestions.
type GetReceivedQuestionsParamsSortBy string

// GetSentQuestionsParams defines parameters for GetSentQuestions.
type GetSentQuestionsParams struct {
	Page      *PaginationQueryPage          `form:"page,omitempty" json:"page,omitempty"`
	Limit     *PaginationQueryLimit         `form:"limit,omitempty" json:"limit,omitempty"`
	HasAnswer *SentQuestionFilterHasAnswer  `form:"hasAnswer,omitempty" json:"hasAnswer,omitempty"`
	SortBy    *GetSentQuestionsParamsSortBy `form:"sortBy,omitempty" json:"sortBy,omitempty"`
	SortOrder *SentQuestionFilterSortOrder  `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`
}

// GetSentQuestionsParamsSortBy defines parameters for GetSentQuestions.
type GetSentQuestionsParamsSortBy string

// BlockUserJSONBody defines parameters for BlockUser.
type BlockUserJSONBody struct {
	UserId string `json:"userId"`
}

// GetBlockedUsersParams defines parameters for GetBlockedUsers.
type GetBlockedUsersParams struct {
	Page  *PaginationQueryPage  `form:"page,omitempty" json:"page,omitempty"`
	Limit *PaginationQueryLimit `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetNgWordsParams defines parameters for GetNgWords.
type GetNgWordsParams struct {
	Page  *PaginationQueryPage  `form:"page,omitempty" json:"page,omitempty"`
	Limit *PaginationQueryLimit `form:"limit,omitempty" json:"limit,omitempty"`
}

// CreateQuestionJSONRequestBody defines body for CreateQuestion for application/json ContentType.
type CreateQuestionJSONRequestBody = QuestionCreateRequest

// ReportContentJSONRequestBody defines body for ReportContent for application/json ContentType.
type ReportContentJSONRequestBody = ReportRequest

// UpdateQuestionJSONRequestBody defines body for UpdateQuestion for application/json ContentType.
type UpdateQuestionJSONRequestBody = QuestionUpdateRequest

// CreateAnswerJSONRequestBody defines body for CreateAnswer for application/json ContentType.
type CreateAnswerJSONRequestBody = AnswerCreateRequest

// RegisterUserJSONRequestBody defines body for RegisterUser for application/json ContentType.
type RegisterUserJSONRequestBody = UserRegistrationRequest

// BlockUserJSONRequestBody defines body for BlockUser for application/json ContentType.
type BlockUserJSONRequestBody BlockUserJSONBody

// LoginUserJSONRequestBody defines body for LoginUser for application/json ContentType.
type LoginUserJSONRequestBody = LoginRequest

// UpdateUserProfileJSONRequestBody defines body for UpdateUserProfile for application/json ContentType.
type UpdateUserProfileJSONRequestBody = ProfileUpdateRequest

// AddNgWordJSONRequestBody defines body for AddNgWord for application/json ContentType.
type AddNgWordJSONRequestBody = NgWordCreateRequest

// AsIdentificator0 returns the union data inside the Identificator as a Identificator0
func (t Identificator) AsIdentificator0() (Identificator0, error) {
	var body Identificator0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIdentificator0 overwrites any union data inside the Identificator as the provided Identificator0
func (t *Identificator) FromIdentificator0(v Identificator0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIdentificator0 performs a merge with any union data inside the Identificator, using the provided Identificator0
func (t *Identificator) MergeIdentificator0(v Identificator0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIdentificator1 returns the union data inside the Identificator as a Identificator1
func (t Identificator) AsIdentificator1() (Identificator1, error) {
	var body Identificator1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIdentificator1 overwrites any union data inside the Identificator as the provided Identificator1
func (t *Identificator) FromIdentificator1(v Identificator1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIdentificator1 performs a merge with any union data inside the Identificator, using the provided Identificator1
func (t *Identificator) MergeIdentificator1(v Identificator1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Identificator) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Identificator) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsProfileTwitter returns the union data inside the ProfileField as a ProfileTwitter
func (t ProfileField) AsProfileTwitter() (ProfileTwitter, error) {
	var body ProfileTwitter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProfileTwitter overwrites any union data inside the ProfileField as the provided ProfileTwitter
func (t *ProfileField) FromProfileTwitter(v ProfileTwitter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProfileTwitter performs a merge with any union data inside the ProfileField, using the provided ProfileTwitter
func (t *ProfileField) MergeProfileTwitter(v ProfileTwitter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsProfileSite returns the union data inside the ProfileField as a ProfileSite
func (t ProfileField) AsProfileSite() (ProfileSite, error) {
	var body ProfileSite
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProfileSite overwrites any union data inside the ProfileField as the provided ProfileSite
func (t *ProfileField) FromProfileSite(v ProfileSite) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProfileSite performs a merge with any union data inside the ProfileField, using the provided ProfileSite
func (t *ProfileField) MergeProfileSite(v ProfileSite) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsProfileEmail returns the union data inside the ProfileField as a ProfileEmail
func (t ProfileField) AsProfileEmail() (ProfileEmail, error) {
	var body ProfileEmail
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProfileEmail overwrites any union data inside the ProfileField as the provided ProfileEmail
func (t *ProfileField) FromProfileEmail(v ProfileEmail) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProfileEmail performs a merge with any union data inside the ProfileField, using the provided ProfileEmail
func (t *ProfileField) MergeProfileEmail(v ProfileEmail) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ProfileField) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ProfileField) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// 画像ファイルをアップロード
	// (POST /api/files/images)
	UploadImage(ctx echo.Context) error
	// 画像ファイルを削除
	// (DELETE /api/files/images/{imageId})
	DeleteImage(ctx echo.Context, imageId string) error
	// 画像ファイルを取得
	// (GET /api/files/images/{imageId})
	GetImage(ctx echo.Context, imageId string) error
	// 新しい質問を送信
	// (POST /api/questions)
	CreateQuestion(ctx echo.Context) error
	// ユーザーの公開質問・回答一覧取得
	// (GET /api/questions/public/{userId})
	GetPublicQAs(ctx echo.Context, userId string, params GetPublicQAsParams) error
	// 受信した質問一覧取得
	// (GET /api/questions/received)
	GetReceivedQuestions(ctx echo.Context, params GetReceivedQuestionsParams) error
	// 不適切なコンテンツを通報
	// (POST /api/questions/report)
	ReportContent(ctx echo.Context) error
	// 送信した質問一覧取得
	// (GET /api/questions/sent)
	GetSentQuestions(ctx echo.Context, params GetSentQuestionsParams) error
	// 質問を削除
	// (DELETE /api/questions/{questionId})
	DeleteQuestion(ctx echo.Context, questionId string) error
	// 質問詳細情報取得
	// (GET /api/questions/{questionId})
	GetQuestionDetail(ctx echo.Context, questionId string) error
	// 質問内容を編集
	// (PATCH /api/questions/{questionId})
	UpdateQuestion(ctx echo.Context, questionId string) error
	// 質問に回答を作成
	// (POST /api/questions/{questionId}/answer)
	CreateAnswer(ctx echo.Context, questionId string) error
	// 質問を既読にマーク
	// (PATCH /api/questions/{questionId}/read)
	MarkQuestionAsRead(ctx echo.Context, questionId string) error
	// 新規ユーザー登録
	// (POST /api/users)
	RegisterUser(ctx echo.Context) error
	// ユーザーをブロック
	// (POST /api/users/block)
	BlockUser(ctx echo.Context) error
	// ユーザーのブロックを解除
	// (DELETE /api/users/block/{userId})
	UnblockUser(ctx echo.Context, userId string) error
	// ブロックしたユーザー一覧取得
	// (GET /api/users/blocked)
	GetBlockedUsers(ctx echo.Context, params GetBlockedUsersParams) error
	// ユーザーログイン
	// (POST /api/users/login)
	LoginUser(ctx echo.Context) error
	// ユーザーログアウト
	// (POST /api/users/logout)
	LogoutUser(ctx echo.Context) error
	// ログイン中のユーザー情報取得
	// (GET /api/users/me)
	GetCurrentUser(ctx echo.Context) error
	// ユーザープロフィール更新
	// (PATCH /api/users/me)
	UpdateUserProfile(ctx echo.Context) error
	// NGワード一覧取得
	// (GET /api/users/ng-words)
	GetNgWords(ctx echo.Context, params GetNgWordsParams) error
	// NGワードを追加
	// (POST /api/users/ng-words)
	AddNgWord(ctx echo.Context) error
	// NGワードを削除
	// (DELETE /api/users/ng-words/{ngWordId})
	DeleteNgWord(ctx echo.Context, ngWordId string) error
	// 公開ユーザー情報取得
	// (GET /api/users/{userId})
	GetPublicUserInfo(ctx echo.Context, userId string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// UploadImage converts echo context to params.
func (w *ServerInterfaceWrapper) UploadImage(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UploadImage(ctx)
	return err
}

// DeleteImage converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteImage(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "imageId" -------------
	var imageId string

	err = runtime.BindStyledParameterWithOptions("simple", "imageId", ctx.Param("imageId"), &imageId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter imageId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteImage(ctx, imageId)
	return err
}

// GetImage converts echo context to params.
func (w *ServerInterfaceWrapper) GetImage(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "imageId" -------------
	var imageId string

	err = runtime.BindStyledParameterWithOptions("simple", "imageId", ctx.Param("imageId"), &imageId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter imageId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetImage(ctx, imageId)
	return err
}

// CreateQuestion converts echo context to params.
func (w *ServerInterfaceWrapper) CreateQuestion(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateQuestion(ctx)
	return err
}

// GetPublicQAs converts echo context to params.
func (w *ServerInterfaceWrapper) GetPublicQAs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameterWithOptions("simple", "userId", ctx.Param("userId"), &userId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPublicQAsParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", false, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", false, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "sortBy" -------------

	err = runtime.BindQueryParameter("form", false, false, "sortBy", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sortBy: %s", err))
	}

	// ------------- Optional query parameter "sortOrder" -------------

	err = runtime.BindQueryParameter("form", false, false, "sortOrder", ctx.QueryParams(), &params.SortOrder)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sortOrder: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetPublicQAs(ctx, userId, params)
	return err
}

// GetReceivedQuestions converts echo context to params.
func (w *ServerInterfaceWrapper) GetReceivedQuestions(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetReceivedQuestionsParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", false, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", false, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", false, false, "status", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status: %s", err))
	}

	// ------------- Optional query parameter "sortBy" -------------

	err = runtime.BindQueryParameter("form", false, false, "sortBy", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sortBy: %s", err))
	}

	// ------------- Optional query parameter "sortOrder" -------------

	err = runtime.BindQueryParameter("form", false, false, "sortOrder", ctx.QueryParams(), &params.SortOrder)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sortOrder: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetReceivedQuestions(ctx, params)
	return err
}

// ReportContent converts echo context to params.
func (w *ServerInterfaceWrapper) ReportContent(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ReportContent(ctx)
	return err
}

// GetSentQuestions converts echo context to params.
func (w *ServerInterfaceWrapper) GetSentQuestions(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSentQuestionsParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", false, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", false, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "hasAnswer" -------------

	err = runtime.BindQueryParameter("form", false, false, "hasAnswer", ctx.QueryParams(), &params.HasAnswer)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hasAnswer: %s", err))
	}

	// ------------- Optional query parameter "sortBy" -------------

	err = runtime.BindQueryParameter("form", false, false, "sortBy", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sortBy: %s", err))
	}

	// ------------- Optional query parameter "sortOrder" -------------

	err = runtime.BindQueryParameter("form", false, false, "sortOrder", ctx.QueryParams(), &params.SortOrder)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sortOrder: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSentQuestions(ctx, params)
	return err
}

// DeleteQuestion converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteQuestion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "questionId" -------------
	var questionId string

	err = runtime.BindStyledParameterWithOptions("simple", "questionId", ctx.Param("questionId"), &questionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter questionId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteQuestion(ctx, questionId)
	return err
}

// GetQuestionDetail converts echo context to params.
func (w *ServerInterfaceWrapper) GetQuestionDetail(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "questionId" -------------
	var questionId string

	err = runtime.BindStyledParameterWithOptions("simple", "questionId", ctx.Param("questionId"), &questionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter questionId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetQuestionDetail(ctx, questionId)
	return err
}

// UpdateQuestion converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateQuestion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "questionId" -------------
	var questionId string

	err = runtime.BindStyledParameterWithOptions("simple", "questionId", ctx.Param("questionId"), &questionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter questionId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateQuestion(ctx, questionId)
	return err
}

// CreateAnswer converts echo context to params.
func (w *ServerInterfaceWrapper) CreateAnswer(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "questionId" -------------
	var questionId string

	err = runtime.BindStyledParameterWithOptions("simple", "questionId", ctx.Param("questionId"), &questionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter questionId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateAnswer(ctx, questionId)
	return err
}

// MarkQuestionAsRead converts echo context to params.
func (w *ServerInterfaceWrapper) MarkQuestionAsRead(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "questionId" -------------
	var questionId string

	err = runtime.BindStyledParameterWithOptions("simple", "questionId", ctx.Param("questionId"), &questionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter questionId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.MarkQuestionAsRead(ctx, questionId)
	return err
}

// RegisterUser converts echo context to params.
func (w *ServerInterfaceWrapper) RegisterUser(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RegisterUser(ctx)
	return err
}

// BlockUser converts echo context to params.
func (w *ServerInterfaceWrapper) BlockUser(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BlockUser(ctx)
	return err
}

// UnblockUser converts echo context to params.
func (w *ServerInterfaceWrapper) UnblockUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameterWithOptions("simple", "userId", ctx.Param("userId"), &userId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UnblockUser(ctx, userId)
	return err
}

// GetBlockedUsers converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockedUsers(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockedUsersParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", false, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", false, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockedUsers(ctx, params)
	return err
}

// LoginUser converts echo context to params.
func (w *ServerInterfaceWrapper) LoginUser(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.LoginUser(ctx)
	return err
}

// LogoutUser converts echo context to params.
func (w *ServerInterfaceWrapper) LogoutUser(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.LogoutUser(ctx)
	return err
}

// GetCurrentUser converts echo context to params.
func (w *ServerInterfaceWrapper) GetCurrentUser(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCurrentUser(ctx)
	return err
}

// UpdateUserProfile converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateUserProfile(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateUserProfile(ctx)
	return err
}

// GetNgWords converts echo context to params.
func (w *ServerInterfaceWrapper) GetNgWords(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetNgWordsParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", false, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", false, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNgWords(ctx, params)
	return err
}

// AddNgWord converts echo context to params.
func (w *ServerInterfaceWrapper) AddNgWord(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AddNgWord(ctx)
	return err
}

// DeleteNgWord converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteNgWord(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ngWordId" -------------
	var ngWordId string

	err = runtime.BindStyledParameterWithOptions("simple", "ngWordId", ctx.Param("ngWordId"), &ngWordId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ngWordId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteNgWord(ctx, ngWordId)
	return err
}

// GetPublicUserInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetPublicUserInfo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameterWithOptions("simple", "userId", ctx.Param("userId"), &userId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetPublicUserInfo(ctx, userId)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/api/files/images", wrapper.UploadImage)
	router.DELETE(baseURL+"/api/files/images/:imageId", wrapper.DeleteImage)
	router.GET(baseURL+"/api/files/images/:imageId", wrapper.GetImage)
	router.POST(baseURL+"/api/questions", wrapper.CreateQuestion)
	router.GET(baseURL+"/api/questions/public/:userId", wrapper.GetPublicQAs)
	router.GET(baseURL+"/api/questions/received", wrapper.GetReceivedQuestions)
	router.POST(baseURL+"/api/questions/report", wrapper.ReportContent)
	router.GET(baseURL+"/api/questions/sent", wrapper.GetSentQuestions)
	router.DELETE(baseURL+"/api/questions/:questionId", wrapper.DeleteQuestion)
	router.GET(baseURL+"/api/questions/:questionId", wrapper.GetQuestionDetail)
	router.PATCH(baseURL+"/api/questions/:questionId", wrapper.UpdateQuestion)
	router.POST(baseURL+"/api/questions/:questionId/answer", wrapper.CreateAnswer)
	router.PATCH(baseURL+"/api/questions/:questionId/read", wrapper.MarkQuestionAsRead)
	router.POST(baseURL+"/api/users", wrapper.RegisterUser)
	router.POST(baseURL+"/api/users/block", wrapper.BlockUser)
	router.DELETE(baseURL+"/api/users/block/:userId", wrapper.UnblockUser)
	router.GET(baseURL+"/api/users/blocked", wrapper.GetBlockedUsers)
	router.POST(baseURL+"/api/users/login", wrapper.LoginUser)
	router.POST(baseURL+"/api/users/logout", wrapper.LogoutUser)
	router.GET(baseURL+"/api/users/me", wrapper.GetCurrentUser)
	router.PATCH(baseURL+"/api/users/me", wrapper.UpdateUserProfile)
	router.GET(baseURL+"/api/users/ng-words", wrapper.GetNgWords)
	router.POST(baseURL+"/api/users/ng-words", wrapper.AddNgWord)
	router.DELETE(baseURL+"/api/users/ng-words/:ngWordId", wrapper.DeleteNgWord)
	router.GET(baseURL+"/api/users/:userId", wrapper.GetPublicUserInfo)

}
